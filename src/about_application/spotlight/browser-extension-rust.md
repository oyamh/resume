# 拡張機能開発(Rust)

## RustによるWebAssembly
- Rustで本格的なブラウザ拡張機能を作った例は、調べた中でほとんどありませんでした。
- 問題が起きたときは、RustやWebAssemblyやブラウザ自体のIssueなどを調べて、解決できそうなこと、今は解決できないことを取捨選択しながら制作しました。

## React経験の応用
- Yew(Rust版React)を使って制作しました。
- Reactによるコンポーネント開発の経験を活かすことができました。

## 依存関係の扱い
- DI(依存注入)の役割を担うContextによって各モジュールを疎結合に保っています。

## gRPC通信
- gRPCを使って通信を行います。
- 通信データには、Protocol Bufferスキーマで定義されたデータ型を使っています。
- Connectで出力した型安全なコードを使ってサーバーと通信を行います。

---

# 実装内容の例A

## 課題
- フォルダ名やタグ名の補完入力

## 機能の内容
- テキストボックスが補完入力の対象なら入力内容に応じて補完候補を表示
- 入力すると即候補一覧が表示
- マウスかキーボードで候補を選択
- 選択した候補がテキストボックスに自動入力

## 工夫した点
- Fuzzy検索の形で補完候補を選定

## 重視した点
- 補完候補の選定の速度パフォーマンス
    - 入力文字列一致の検証は最低限の検証のみを行う
        - 全て含まれているか
        - 順番通り含まれているか
        - 以上の検証をパスしたものだけスコア算出開始
    - スコア算出のアルゴリズムをできる限りシンプルにする
        - 一致していたらボーナス
        - 連鎖していたらボーナス
        - 頭文字が一致していたらボーナス
        - これらが満たされない場合はペナルティ

## 問題点
- 補完候補のヒット率の低下が予想された
    - 現状不満は感じない

## 使用した技術
- Rust
- WebAssembly

---

# 実装内容の例B

## 課題
- モジュール依存関係の分離

## 機能の内容
- 機能の追加に応じて依存関係を付け足せる
- 機能の削除に応じて依存関係を切り離せる
- テスト時には依存関係をMockと入れ替えられる

## 工夫した点
- 依存関係には必ずインターフェイスでアクセス
    - 依存関係をContextモジュールに収めて、インターフェイス(Trait)でContext構造体から依存関係を取り出して、依存する機能を使う
        - メソッドとして機能をまとめたTraitを定義する
        - そのTraitを返すProvider Traitを定義する
        - Context構造体のプロパティに依存する構造体を定義する
        - 依存する構造体を返すProvider TraitのprovideメソッドをContext構造体に実装する

## 重視した点
- 依存関係をContextモジュールに集約
    - 新しく依存を追加する時にはContextを追加するだけ
    - 不要な依存を削除する時にはContextを削除するだけ
    - Mockと入れ替える時にはMock用Contextと入れ替えるだけ

## 問題点
- 機能ごとにContextモジュールを作ってしまったので、粒度が小さすぎる
    - 機能ごとよりも、単純な依存関係のまとまりとしてContextモジュールを作るべきか検証が必要

## 使用した技術
- Rust
- WebAssembly
